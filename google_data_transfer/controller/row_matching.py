import logging

import pandas as pd
from fuzzywuzzy import fuzz

logger = logging.getLogger(__name__)

STRING_REPLACE_MAP = {"č": "c", "ć": "c", "š": "s", "ž": "z", "đ": "d", " ": ""}


def _preprocess_string(s: str):
    """Preprocess a string.

    Args:
        s: The string to preprocess

    Returns:
        The preprocessed string

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    s = s.lower()
    for old, new in STRING_REPLACE_MAP.items():
        s = s.replace(old, new)
    return s


def _match_strings(s1: str, s2: str, string_metric: callable = fuzz.ratio) -> float:
    """Match two strings

    Args:
        s1: First string
        s2: Second string
        string_metric: A callable that takes two strings and returns a float

    Returns:
        The distance between the two strings

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    s1 = _preprocess_string(s1)
    s2 = _preprocess_string(s2)
    string_distance = string_metric(s1, s2)
    return string_distance


def match_sheet_with_form_fuzzy(
    form_df: pd.DataFrame, sheet_df: pd.DataFrame, columns_join_map: dict[str:str]
) -> dict[tuple:tuple]:
    """Match rows in a form with rows in a sheet.

    Args:
        form_df: Dataframe of the form
        sheet_df: Dataframe of the sheet
        columns_join_map: A dictionary mapping columns in the form to columns in the sheet.

    Returns:
        A dictionary mapping rows in the sheet to rows in the form.

    !!! note

        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)
    """
    matched_row_map = {}
    form_cols = columns_join_map.keys()
    sheet_cols = columns_join_map.values()
    for sheet_row in sheet_df[sheet_cols].values:
        max_score = 0
        max_score_form_row = None
        for form_row in form_df[form_cols].values:
            # If already matched
            if tuple(form_row) in matched_row_map.values():
                continue
            total_score = 0
            # Calculate string similarity metric for every column, add to total score
            for form_val, sheet_val in zip(form_row, sheet_row):
                cur_match = _match_strings(form_val, sheet_val)
                total_score += cur_match
            # If the score is max, match rows
            if total_score >= max_score:
                max_score = total_score
                max_score_form_row = form_row
        matched_form_row = tuple(max_score_form_row)
        # Allow 10% difference between each string
        # TODO: make the limit configurable. Optionally match each string individually
        if max_score < 90 * len(sheet_cols):
            logger.warning(
                f"Weak match [{max_score / len(sheet_cols)}%] between existing sheet row and best form response match: "
                f"<SHEET> {sheet_row}: <FORM> {max_score_form_row}. This row was skipped."
            )
            matched_form_row = None
        matched_row_map[tuple(sheet_row)] = matched_form_row
    return matched_row_map
